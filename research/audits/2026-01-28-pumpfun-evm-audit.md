# ðŸš¨ Security Audit Report: PumpFun-EVM-Smart-Contract

**Date:** 2026-01-28  
**Repo:** https://github.com/AlphaFox000/PumpFun-EVM-Smart-Contract  
**Auditor:** Kindred (Nightly Scan)  
**Severity:** CRITICAL

---

## Executive Summary

Found **3 CRITICAL** and **2 HIGH** severity vulnerabilities in this Pump.fun clone. The most severe issue allows **anyone to drain all ETH from any trading pair**.

---

## Critical Findings

### ðŸ”´ CRITICAL-01: Unrestricted ETH Drain in Pair.sol

**File:** `contracts/Pair.sol` (Line ~119)

```solidity
function transferETH(address _address, uint256 amount) public returns (bool) {
    require(_address != address(0), "Zero addresses are not allowed.");
    (bool os, ) = payable(_address).call{value: amount}("");
    return os;
}
```

**Impact:** Anyone can call `transferETH()` and drain ALL ETH from any Pair contract.

**PoC:**
```solidity
// Attacker calls:
pair.transferETH(attackerAddress, pair.balance());
// Result: All ETH gone
```

**Fix:** Add access control modifier (onlyRouter or onlyFactory)

---

### ðŸ”´ CRITICAL-02: Missing Access Control on Fee Update

**File:** `contracts/PumpFun.sol` (Line ~148)

```solidity
function updateLaunchFee(uint256 _fee) public returns (uint256) {
    fee = _fee;
    return _fee;
}
```

**Impact:** Anyone can set launch fee to 0 (or any value), bypassing protocol revenue.

**Fix:** Add `onlyOwner` modifier

---

### ðŸ”´ CRITICAL-03: Unrestricted Pool Manipulation

**File:** `contracts/Pair.sol`

```solidity
function swap(uint256 amount0In, uint256 amount0Out, uint256 amount1In, uint256 amount1Out) public returns (bool)
function mint(uint256 reserve0, uint256 reserve1, address _lp) public returns (bool)
```

**Impact:** Anyone can call `swap()` and `mint()` directly to manipulate pool reserves and steal funds.

---

## High Findings

### ðŸŸ  HIGH-01: Unbounded Loop DoS

**File:** `contracts/PumpFun.sol` (Lines ~278, ~327)

```solidity
for (uint i = 0; i < tokens.length; i++) {
    if(tokens[i].token == tk) { ... }
}
```

**Impact:** As more tokens are launched, these loops grow unbounded. Eventually transactions will exceed block gas limit, bricking the contract.

---

### ðŸŸ  HIGH-02: Integer Division Precision Loss

**File:** Multiple locations

```solidity
uint256 price = newReserveA / _newReserveB;
```

**Impact:** Price calculations lose precision, enabling front-running and arbitrage extraction.

---

## Medium Findings

### ðŸŸ¡ MED-01: Hardcoded Uniswap Router Address

```solidity
uniswapV2Router = IUniswapV2Router02(0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24);
```

**Impact:** Only works on one chain, limits deployment flexibility.

---

## Recommendations

1. **Immediate:** Do not deploy this code to mainnet
2. Add proper access control to all sensitive functions
3. Use OpenZeppelin's AccessControl or Ownable patterns
4. Implement bounded loops or pagination
5. Consider professional audit before launch

---

## Bug Bounty Potential

This is NOT an active bug bounty target (educational/fork repo). However, if deployed live:
- CRITICAL-01 alone would be worth **$50k-$500k** depending on TVL
- Combined severity: **Protocol-breaking**

---

*Generated by Kindred ðŸº - Nightly Audit Scan*
